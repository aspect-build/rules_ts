# Note, Bazel 6 starlark has lambda so maybe we can stop using partial
load("@bazel_skylib//lib:partial.bzl", "partial")
load("@bazel_skylib//rules:write_file.bzl", "write_file")
load("@aspect_rules_swc//swc:defs.bzl", "swc_transpiler")
load("@aspect_rules_ts//ts:defs.bzl", "ts_project")
load(":babel.bzl", "babel")

# Our test fixture is a large enough file that the transpilation difference is measurable
write_file(
    name = "gen_ts",
    out = "big.ts",
    content = [
        "export const a{0}: number = {0}".format(x)
        for x in range(10000)
    ],
)

# Uses TypeScript (tsc) for both type-checking and transpilation
# % bazel build tsc
# INFO: Elapsed time: 6.798s, Critical Path: 5.24s
ts_project(
    name = "tsc",
    srcs = ["big.ts"],
    declaration = True,
    source_map = True,
)

# Runs swc to transpile ts -> js
# and tsc to type-check.
# % bazel build swc
# INFO: Elapsed time: 0.745s, Critical Path: 0.54s
#
# Optionally, or on CI, you can explicitly do the slow type-check:
# $ bazel build swc_typecheck
# INFO: Elapsed time: 3.330s, Critical Path: 3.19s
ts_project(
    name = "swc",
    srcs = ["big.ts"],
    out_dir = "build-swc",
    # Partial allows us to apply some arguments here, while ts_project applies the rest.
    # See https://en.wikipedia.org/wiki/Partial_application
    # and https://docs.aspect.dev/bazelbuild/bazel-skylib/1.1.1/docs/partial.html
    transpiler = partial.make(
        swc_transpiler,
        # Attributes to the swc rule can appear here
        args = ["--env-name=test"],
        swcrc = ".swcrc",
    ),
)

# Runs babel to transpile ts -> js
# and tsc to type-check
# % bazel build babel
# INFO: Elapsed time: 3.928s, Critical Path: 3.73s
#
# Like the swc example, you could build babel_typecheck to run tsc.
ts_project(
    name = "babel",
    srcs = ["big.ts"],
    out_dir = "build-babel",
    transpiler = babel,
)

# A file that can be transpiled, but fails to typecheck
write_file(
    name = "gen_typeerror",
    out = "typeerror.ts",
    content = ["const a: string = 1"],
)

# This target proves that transpilation doesn't require typechecking:
#
# $ bazel build examples/swc:transpile_with_typeerror
# INFO: Analyzed target //examples/swc:transpile_with_typeerror (1 packages loaded, 8 targets configured).
# Target //examples/swc:transpile_with_typeerror up-to-date:
#   bazel-bin/examples/swc/typeerror.js
#
# But the _typecheck target fails to build:
#
# $ bazel build examples/swc:transpile_with_typeerror_typecheck
# INFO: Analyzed target //examples/swc:transpile_with_typeerror_typecheck (0 packages loaded, 1 target configured).
# ERROR: /home/alexeagle/Projects/rules_ts/examples/swc/BUILD.bazel:30:11: Compiling TypeScript project //examples/swc:transpile_with_typeerror_typings
# examples/swc/typeerror.ts(1,14): error TS2322: Type 'number' is not assignable to type 'string'
ts_project(
    name = "transpile_with_typeerror",
    srcs = ["typeerror.ts"],
    # The transpile_with_typeerror.check target will have a build failure
    # But the default transpile_with_typeerror target should still produce JS outs
    tags = ["manual"],
    transpiler = swc_transpiler,
)
